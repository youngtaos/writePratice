# 浏览器

## 什么是协商缓存（304）？

### 原理：

- 当客户端向服务端发送请求的时候，服务端会校验是否有对应的一个标识，这个标识可以标志缓存资源是否过期；
- 没有这个标识的话，说明资源是第一次请求，服务端会把相应标识发给客户端；
- 客户端下一次去请求这个资源的时候，会携带这个标识去服务端，服务端会对这个标识进行对比；
- 如果对比结果是资源没有更新的话，说明缓存被命中，服务端会相应 304；
- 反之则返回 200，将最新的资源返给客户端，进行数据更新

### 两种标识方式（Last-Modifed + If-Modified-Since 和 Etag + If-None-Match）：

1. Last-Modifed + If-Modified-Since:

- 客户端向服务端请求数据时候，服务端会发送 Last-Modifed 给客户端（一个 GMT 时间）；
- 客户端在下一次请求这个资源的时候，请求头里面加 If-Modified-Since （这个值的值为上次的 Last-Modifed ）给服务端；
- 服务端会将客户端发送的 If-Modified-Since 和当前的 Last-Modifed 进行对比；
- 如果对比结果是资源没有更新的话，说明缓存被命中，服务端会相应 304；
- 反之则返回 200，将最新的资源返给客户端，进行数据更新

2. Etag + If-None-Match：

- 客户端向服务端请求数据时候，服务端会发送 Etag 给客户端（一个唯一标识符）；
- 客户端在下一次请求这个资源的时候，请求头里面加 If-None-Match （值是 Etag 的值）给服务端；
- 服务端会将客户端发送的 If-None-Match 和当前的 Etag 进行对比；
- 如果对比结果是资源没有更新的话，说明缓存被命中，服务端会相应 304；
- 反之则返回 200，将最新的资源返给客户端，进行数据更新

## 重绘和重排（回流）

### 重绘

某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）； 例如：修改元素的填充颜色，会触发重绘；

**修改 css 样式**

- color
- border-style
- border-radius
- text-decoration
- box-shadow
- outline
- background

### 重排（回流）

重新生成布局，重新排列元素（重新计算各节点和 css 具体的大小和位置：渲染树需要重新计算所有受影响的节点\*\*）；例如：改元素的宽高，会触发重排；

**导致重排的情况**

- 添加/删除可见的 DOM 元素
- 页面初始渲染，这是开销最大的一次重排
- 改变元素位置，
- 改变元素尺寸，比如边距、填充、边框、宽度和高度等
- 改变元素内容，比如文字数量，图片大小等
- 改变元素字体大小
- 改变浏览器窗口尺寸，比如 resize 事件发生时
- 激活 CSS 伪类（例如：:hover）
- 设置 style 属性的值，因为通过设置 style 属性改变结点样式的话，每一次设置都会触发一次 reflow
- 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight 等，除此之外，当我们调用 getComputedStyl 方法，或者 IE 里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”

<font  color=#CC3333>重绘不一定导致重排，但重排一定会导致重绘</font>

## 前端的数据缓存有哪些方案呢,有什么区别

1. localStorage, sessionStorage, cookie
2. 相同点： 都保存在浏览器里面，且同源
3. 不同点：
   cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递；cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。存储大小限制也不同，

- **存储大小不同**
  - cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识
  - 而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。
- **数据有效期不同**
  - sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；
  - localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据
  - cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。
- **作用域不同**
  - sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；
  - localStorage 在所有同源窗口中都是共享的；
  - cookie 也是在所有同源窗口中都是共享的。

### Web Storage(localStorage, SessionStorage, Cookie)

    - Web Storage支持事件通知机制，可以将数据更新的通知发送给监听者
    - Web Storage 的 api 接口使用更方便。
    - 减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递。
    - 快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。
    - 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便

## 进程和线程

当启动一个程序时，操作系统就会给该程序创建一个内存空间（当程序被中止时，该内存空间就会被回收），该内存空间就是用来存放程序代码，运行中的数据和一个执行任务的主线程，这样的一个运行环境（内存空间）就被称为进程。
而线程就是依附于进程的，进程将任务分为多个细小任务，分配给多个线程单独执行，可以提高运行效率。

## 从浏览器地址栏输入 URL 后会发生什么
